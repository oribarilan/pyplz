{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyplz","text":"<p>Python-first Friction-free Task Runner.</p> <p>\u26a0\ufe0f Please note \u26a0\ufe0f</p> <p><code>pyplz</code> is currently in early development. While it is already usable, some features are still missing, incomplete or not fully documented. Feel free to open an issue if you have any feedback or suggestions.</p> <p> </p> <p> </p> <p></p> <pre><code>pip install pyplz\n</code></pre>"},{"location":"#why-use-a-task-runner","title":"Why use a task runner?","text":"<p>A task runner automates tasks like building, testing, and deploying, making them faster and more reliable. It ensures consistent execution and simplifies collaboration  by providing clear, reusable commands.</p>"},{"location":"#why-pyplz","title":"Why <code>pyplz</code>?","text":"<p><code>pyplz</code> aims to be a friction-free task runner. While many task runners simplify development, they can also add friction with unfamiliar syntax, extra tools, or difficult integrations.</p> <p>\ud83d\udc0d Python-first: Leverage familiar Python syntax\u2014if you know Python, you know <code>pyplz</code>.  </p> <p>\ud83e\udd17 Author-friendly: Intuitive and ready to use out of the box, with built-in support for development &amp; debugging.  </p> <p>\ud83d\udcbb CLI-compliant: Enjoy a command-line interface that adheres to GNU and POSIX conventions, ensuring a seamless terminal experience.</p> <p>\ud83d\udd17 Integration-ready: Whether you're running Python locally, in containers, or in a CI/CD pipeline, <code>pyplz</code> fits seamlessly into your environment.  </p> <p>\ud83d\udcda Documented: Access extensive documentation and automatically generated task-specific help, ensuring you always have the information you need.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<ol> <li>Using python 3.9 or later, run <code>pip install pyplz</code></li> <li>Create a <code>plzfile.py</code> in the root of your project</li> <li>Using your terminal, execute <code>plz</code> in the root of your project</li> </ol> <p>Development Dependencies</p> <p>For best practice, include development dependencies (e.g., <code>pytest</code>) in a dedicated file (such as <code>requirements.dev.txt</code>). Add <code>pyplz</code> to your dev dependencies to ensure it's available out of the box for every project contributor.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Create your first task by making a <code>plzfile.py</code> in your project root:</p> <pre><code>from pyplz import plz\n\n@plz.task()\ndef test():\n    \"\"\"Test the project.\"\"\"\n    plz.run(\"pytest\")\n</code></pre> <p>To add options for test unit tests only (e.g., without integration tests), or adding test coverage, update your task as follows:</p> <pre><code>from pyplz import plz\n\n@plz.task()\ndef test(unit_only: bool = False, coverage: bool = False):\n    \"\"\"Test the project.\"\"\"\n    marks = \"-m unit\" if unit_only else \"\"\n    cov = \"--cov\" if coverage else \"\"\n    plz.run(f\"pytest {marks} {cov}\")\n</code></pre> <p>You can view task-specific help with: <pre><code>\u276f plz test -h\nusage: plz [-h] [--unit-only] [--coverage]\n\nTest the project.\n\nsystem options:\n  -h, --help   Show this help message and exit.\n\noptional arguments:\n  --unit-only  Set unit_only to True (bool, default: false)\n  --coverage   Set coverage to True (bool, default: false)\n</code></pre></p> <p>Now, your <code>test</code> task can continue to evolve, without needing some special documentation in a separate file, or a slack message to update your team members!</p> <p>Read through our documentation to learn how you can use environment variables, define task dependencies and much more!</p>"},{"location":"backlog/","title":"Backlog","text":""},{"location":"backlog/#features","title":"Features","text":"feature implemented tested doced env dotenv v v v env task definition v v v env in-line v v v env config v v v plz declare file path (-f) list v default v v help v v dependencies v v v plz.run with *args v v v verbosity ask v"},{"location":"backlog/#should","title":"Should","text":"<ul> <li> bug - double tasks in PR (both push and pull_request), which is not needed</li> <li> doc pages</li> <li> move to toml based setup</li> <li> CI with test</li> <li> CI with test coverage</li> <li> CD</li> <li> badges</li> <li> work on coverage</li> <li> bug of trace when command fails (1 output in white, 1 output in red, then long traceback)</li> <li> convert _ to - in task names</li> <li> what's new (changelog) + versioning</li> <li> testable examples in docs</li> <li> --show-env and --show-env-all in task parser as well</li> </ul>"},{"location":"backlog/#could","title":"Could","text":"<ul> <li> heirachial loading</li> <li> <code>plz .create-demo</code></li> <li> async commands</li> <li> <code>plz.progress</code></li> <li> support options for commands</li> <li> \"Did you mean?\" offer another command if something resembles it.</li> </ul>"},{"location":"contribution/contribution/","title":"Contribution","text":""},{"location":"contribution/contribution/#installation","title":"Installation","text":"<ol> <li>Python 3.9</li> <li>Create a virtual environment: <code>python -m venv .venv</code></li> <li>Activate the virtual environment:</li> <li>On macOS and Linux: <code>source .venv/bin/activate</code></li> <li>On Windows: <code>.venv\\Scripts\\activate</code></li> <li>Upgrade pip: <code>pip install --upgrade pip</code></li> <li>Install dependencies: <code>pip install -r requirements.dev.txt</code></li> <li>In the root directory: <code>pip install -e .</code></li> </ol>"},{"location":"features/dependencies/","title":"Dependencies","text":"<p>Tasks can depend on other tasks. This is useful when one or more tasks a required to run before another task. </p> <p>For example, you may have a <code>lint</code> task that lints your code, and another <code>test</code> task that runs your tests. Then, you may want to have a third <code>validate</code> task that will run <code>lint</code> and <code>test</code>.</p> <p>This can look like this:</p> <pre><code>@plz.task()\ndef lint():\n    plz.run(\"ruff\")\n\n@plz.task()\ndef test():\n    plz.run(\"pytest\")\n\n@plz.task(requires=[lint, test])\ndef validate():\n    plz.print(\"validation successful\")\n</code></pre> <p>Task dependencies can be defined in a few ways: 1. A single task <code>@plz.task(requires=lint)</code> 2. A list of tasks or tasks with arguments    1. <code>@plz.task(requires=[lint, test])</code>    2. <code>@plz.task(requires=[(lint, \"arg1\"), (test, \"arg2\")])</code>    3. <code>@plz.task(requires=[lint, (test, (\"arg1\", \"arg2\"))])</code></p>"},{"location":"features/env_vars/","title":"Environment Variables","text":""},{"location":"features/env_vars/#defining-environment-variables","title":"Defining Environment Variables","text":"<p><code>pyplz</code> has extensive support for environment variables.</p>"},{"location":"features/env_vars/#env-file","title":".env file","text":"<p><code>pyplz</code> will automatically load environment variables from a <code>.env</code> file in the same level of your <code>plzfile</code>. Each line in the file should be in the format <code>KEY=VALUE</code>.</p> <p>These variables will be available to all tasks (i.e., <code>plz-level</code>).</p>"},{"location":"features/env_vars/#configuration","title":"Configuration","text":"<p><code>pyplz</code> supports being configured from within the <code>plzfile</code> itself. Among other things, you can define environment variables in the configuration. For more information, see the Configuration documentation.</p> <p>These variables are <code>plz-level</code> as well.</p> <pre><code>import os\nfrom pyplz import plz\n\nplz.configure(env={\"a\": \"1\", \"b\": \"2\"})\n\n@plz.task()\ndef my_task():\n    print(os.environ[\"a\"])\n</code></pre>"},{"location":"features/env_vars/#task-definition","title":"Task Definition","text":"<p>You can define environment variables for a specific task by using the <code>envs</code> parameter in the task definition.</p> <pre><code>import os\nfrom pyplz import plz\n\n@plz.task(envs={\"foo\": \"bar\"})\ndef my_task():\n    print(os.environ[\"foo\"])\n</code></pre> <p>These variables will only be available to the task they are defined for (i.e., <code>task-level</code>).</p>"},{"location":"features/env_vars/#in-line","title":"In-line","text":"<p>You can also define environment variables in-line when running a task, using the <code>-e</code> or <code>--env</code> flag per variable.</p> <p>These variables are <code>task-level</code> as well.</p> <p>For example:</p> <pre><code>plz -e VERBOSE=true -e DEBUG=true build\n</code></pre> <p>Note that in-line variables are defined before the task name, as can be seen in <code>plz -h</code>.</p>"},{"location":"features/env_vars/#showing-environment-variables","title":"Showing Environment Variables","text":"<p>You can see environment variables available to a task by using the <code>--show-env</code> (pyplz variables) or <code>--show-env-all</code> (all accessible variables) flags.</p>"},{"location":"features/help/","title":"Auto Help","text":"<p><code>pyplz</code> offers dynamic help documentation, so your tasks get command-line documentation automatically.</p>"},{"location":"features/help/#plz-level-help","title":"plz-level help","text":"<p>The <code>plz</code> command has a built-in help system. You can access it by running <code>plz -h</code> or <code>plz --help</code>. </p>"},{"location":"features/help/#task-level-help","title":"task-level help","text":"<p><code>pyplz</code> generates dynamic cli help documentation for your defined tasks. Refrence it by running:</p> <pre><code>plz &lt;some-task-name&gt; -h\n</code></pre> <p>Tip</p> <p>Task docstring will appear in the help documentation.</p>"},{"location":"features/run/","title":"Command Execution (Run)","text":"<p>TODO - link to the run API</p> <p><code>run</code> is the most basic function in <code>plz</code> and is used to run any terminal command.</p> <p>Run has many different options and flags to help you run your commands in the way you want. You can refrence the API documentation for more information, or explore the function documentation in-code.</p> <p>For now, here is a simple example of how to use <code>run</code>:</p> <pre><code>@plz.task()\ndef my_task():\n    # Run any terminal command\n    plz.run(\"echo Hello, World!\")\n</code></pre>"}]}